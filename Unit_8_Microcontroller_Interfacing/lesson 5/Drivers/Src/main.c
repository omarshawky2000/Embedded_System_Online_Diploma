/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2023 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include "stm32f103x6.h"
#include "Stm32_F103C6_GPIO_Driver.h"
#include "Stm32_F103C6_UART_Driver.h"
#include "Stm32_F103C6_EXTI_Driver.h"
#include "Stm32_F103C6_SPI_Driver.h"

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif

//#define 	MCU_SLAVE
#define	MCU_MASTER

uint16_t ch ;

void clock_init()
{
	//Enable clock for GPIO
	RCC_GPIOA_CLK_EN();
	RCC_GPIOB_CLK_EN();

	//Enable AFIO
	RCC_AFIO_CLK_EN();
}

void Omar_UART_IRQ_Callback(void)
{
	MCAL_UART_ReceiveData(USART1, &ch, disable);
	MCAL_UART_SendData(USART1, &ch, enable);

#ifdef MCU_MASTER
	//Send to SPI
	MCAL_GPIO_Write_PIN(GPIOA, GPIO_PIN_4, GPIO_PIN_LOW);
	MCAL_SPI_TX_RX(SPI1 ,  &ch , SPI_POLL_enable);
	MCAL_GPIO_Write_PIN(GPIOA, GPIO_PIN_4, GPIO_PIN_HIGH);
#endif

}



 int main(void)
 {
	 UART_Config_t UART_Cfg;



	 clock_init();

	 UART_Cfg.USART_BAUDRATE = USART_BAUDRATE_115200;
	 UART_Cfg.USART_FLWCTRL = USART_FLWCTRL_NONE;
	 UART_Cfg.USART_IRQ_ENABLE = USART_IRQ_ENABLE_RXNEIE ;
	 UART_Cfg.USART_PARITY = USART_PARITY_NONE;
	 UART_Cfg.USART_PAYLOAD_LENGTH = USART_PAYLOAD_LENGTH_8Bits;
	 UART_Cfg.USART_STOP = USART_STOP_ONE;
	 UART_Cfg.USART_MODE = USART_MODE_TX_RX;
	 UART_Cfg.P_IRQ_CALLBACK = Omar_UART_IRQ_Callback ;

	 MCAL_UART_Init(USART1, &UART_Cfg);
	 MCAL_UART_GPIO_Set_Pins(USART1);

	 //SPI Init
	 SPI_Config_t SPI_Cfg ;

	 SPI_Cfg.SPI_CLK_PHASE = SPI_CLK_PHASE_SEC_EDGE_SMPL;
	 SPI_Cfg.SPI_DATA_SIZE = SPI_DATA_SIZE_8BITS;
	 SPI_Cfg.SPI_CLK_POLARITY = SPI_CLK_POLARITY_IDLE_HIGH;
	 SPI_Cfg.SPI_FRAME_FORMAT = SPI_FRAME_FORMAT_MSB_FIRST;

	 //Assume by default that the pclk2 = 8 MHz
	 SPI_Cfg.SPI_BR_PRESC = SPI_BR_PRESC_8;

#ifdef MCU_MASTER
	 SPI_Cfg.SPI_DEVICE_MODE = SPI_DEVICE_MODE_MASTER;
	 SPI_Cfg.SPI_IRQ_ENABLE = SPI_IRQ_ENABLE_NONE;
	 SPI_Cfg.SPI_NSS = SPI_NSS_SW_NSSI_SET;
	 SPI_Cfg.P_IRQ_CALLBACK = NULL;

#endif

#ifdef MCU_SLAVE

#endif

	 MCAL_SPI_Init(SPI1, &SPI_Cfg);
	 MCAL_SPI_GPIO_Set_Pins(SPI1);

	 //Configure SS on PA4 by GPIO
	 GPIO_PinConfig_t PIN_Cfg;
	 PIN_Cfg.GPIO_PinNumber = GPIO_PIN_4;
	 PIN_Cfg.GPIO_MODE = GPIO_MODE_OUTPUT_PP;
	 PIN_Cfg.GPIO_OUTPUT_SPEED = GPIO_SPEED_10M;

	 MCAL_GPIO_Init(GPIOA, PIN_Cfg);

	 //Force the Slave Select to High
	 MCAL_GPIO_Write_PIN(GPIOA, GPIO_PIN_4, GPIO_PIN_HIGH);



	/*Loop Forever*/
	while (1)
		{

		}

 }

